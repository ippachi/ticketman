# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `redis-store` gem.
# Please instead update this file by running `bin/tapioca gem redis-store`.

class Redis
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions
  include ::Redis::Commands

  def initialize(options = T.unsafe(nil)); end

  def _client; end
  def close; end
  def commit; end
  def connected?; end
  def connection; end
  def disconnect!; end
  def dup; end
  def id; end
  def inspect; end
  def multi(&block); end
  def pipelined(&block); end
  def queue(*command); end
  def with; end
  def with_reconnect(val = T.unsafe(nil), &blk); end
  def without_reconnect(&blk); end

  private

  def _subscription(method, timeout, channels, block); end
  def send_blocking_command(command, timeout, &block); end
  def send_command(command, &block); end
  def synchronize; end

  class << self
    def current; end
    def current=(redis); end
    def deprecate!(message); end
    def exists_returns_integer; end
    def exists_returns_integer=(value); end
    def raise_deprecations; end
    def raise_deprecations=(_arg0); end
    def sadd_returns_boolean; end
    def sadd_returns_boolean=(_arg0); end
    def silence_deprecations; end
    def silence_deprecations=(_arg0); end
  end
end

Redis::BASE_PATH = T.let(T.unsafe(nil), String)
class Redis::Deprecated < ::StandardError; end

class Redis::DistributedStore < ::Redis::Distributed
  def initialize(addresses, options = T.unsafe(nil)); end

  def get(key, options = T.unsafe(nil)); end
  def nodes; end
  def reconnect; end
  def redis_version; end
  def ring; end
  def set(key, value, options = T.unsafe(nil)); end
  def setex(key, expiry, value, options = T.unsafe(nil)); end
  def setnx(key, value, options = T.unsafe(nil)); end
  def supports_redis_version?(version); end

  private

  def _extend_namespace(options); end
  def _merge_options(address, options); end
end

class Redis::Store < ::Redis
  include ::Redis::Store::RedisVersion
  include ::Redis::Store::Interface
  include ::Redis::Store::Ttl

  def initialize(options = T.unsafe(nil)); end

  def location; end
  def reconnect; end
  def to_s; end

  private

  def _extend_marshalling(options); end
  def _extend_namespace(options); end
end

class Redis::Store::Factory
  def initialize(*options); end

  def create; end

  private

  def extract_addresses_and_options(*options); end

  class << self
    def create(*options); end
    def extract_host_options_from_hash(options); end
    def extract_host_options_from_uri(uri); end
    def host_options?(options); end
    def normalize_key_names(options); end
    def resolve(uri); end
  end
end

Redis::Store::Factory::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

module Redis::Store::Interface
  def get(key, options = T.unsafe(nil)); end
  def set(key, value, options = T.unsafe(nil)); end
  def setex(key, expiry, value, options = T.unsafe(nil)); end
  def setnx(key, value, options = T.unsafe(nil)); end
end

Redis::Store::Interface::REDIS_SET_OPTIONS = T.let(T.unsafe(nil), Array)

module Redis::Store::Namespace
  def decrby(key, increment); end
  def del(*keys); end
  def exists(*keys); end
  def exists?(*keys); end
  def expire(key, ttl); end
  def flushdb; end
  def get(key, *args); end
  def hdel(key, *fields); end
  def hexists(key, field); end
  def hget(key, field); end
  def hgetall(key); end
  def hincrby(key, field, increment); end
  def hincrbyfloat(key, field, increment); end
  def hkeys(key); end
  def hlen(key); end
  def hmget(key, *fields, &blk); end
  def hmset(key, *attrs); end
  def hscan(key, *args, **_arg2); end
  def hscan_each(key, *args, **_arg2); end
  def hset(key, *args); end
  def hsetnx(key, field, val); end
  def hvals(key); end
  def incrby(key, increment); end
  def keys(pattern = T.unsafe(nil)); end
  def mget(*keys, &blk); end
  def scan(cursor, match: T.unsafe(nil), **kwargs); end
  def set(key, *args, **_arg2); end
  def setex(key, *args, **_arg2); end
  def setnx(key, *args, **_arg2); end
  def to_s; end
  def ttl(key, options = T.unsafe(nil)); end
  def unlink(*keys); end
  def watch(*keys); end
  def with_namespace(ns); end
  def zadd(key, *args); end
  def zincrby(key, increment, member); end
  def zrem(key, member); end
  def zscore(key, member); end

  private

  def interpolate(key); end
  def namespace(key); end
  def namespace_regexp; end
  def namespace_str; end
  def strip_namespace(key); end
end

Redis::Store::Namespace::FLUSHDB_BATCH_SIZE = T.let(T.unsafe(nil), Integer)

module Redis::Store::RedisVersion
  def redis_version; end
  def supports_redis_version?(version); end
end

module Redis::Store::Serialization
  def get(key, options = T.unsafe(nil)); end
  def mget(*keys, &blk); end
  def mset(*args); end
  def set(key, value, options = T.unsafe(nil)); end
  def setex(key, expiry, value, options = T.unsafe(nil)); end
  def setnx(key, value, options = T.unsafe(nil)); end

  private

  def _marshal(val, options); end
  def _unmarshal(val, options); end
  def encode(string); end
  def marshal?(options); end
  def unmarshal?(result, options); end
end

module Redis::Store::Ttl
  def set(key, value, options = T.unsafe(nil)); end
  def setnx(key, value, options = T.unsafe(nil)); end

  protected

  def setnx_with_expire(key, value, ttl, options = T.unsafe(nil)); end

  private

  def expires_in(options); end
  def with_multi_or_pipelined(options, &block); end
end

Redis::Store::VERSION = T.let(T.unsafe(nil), String)
Redis::VERSION = T.let(T.unsafe(nil), String)
