# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rr` gem.
# Please instead update this file by running `bin/tapioca gem rr`.

# source://rr//lib/rr/core_ext/array.rb#1
class Array
  include ::Enumerable

  # @return [Boolean]
  #
  # source://rr//lib/rr/core_ext/array.rb#2
  def wildcard_match?(other); end
end

# source://rr//lib/rr/core_ext/enumerable.rb#1
module Enumerable
  # @return [Boolean]
  #
  # source://rr//lib/rr/core_ext/enumerable.rb#2
  def wildcard_match?(other); end
end

# source://rr//lib/rr/core_ext/hash.rb#1
class Hash
  include ::Enumerable

  # @return [Boolean]
  #
  # source://rr//lib/rr/core_ext/hash.rb#2
  def wildcard_match?(other); end
end

# source://rr//lib/rr/keyword_arguments.rb#1
module RR
  extend ::RR::DoubleDefinitions::Strategies::StrategyMethods
  extend ::RR::DSL

  class << self
    # source://rr//lib/rr/integrations.rb#15
    def adapters; end

    # source://rr//lib/rr/integrations.rb#19
    def adapters_by_name; end

    # source://rr//lib/rr/integrations.rb#29
    def applicable_adapters; end

    # source://rr//lib/rr/autohook.rb#3
    def autohook; end

    # source://rr//lib/rr/without_autohook.rb#109
    def blank_slate_whitelist(*args, &block); end

    # Returns the value of attribute debug.
    #
    # source://rr//lib/rr/without_autohook.rb#115
    def debug; end

    # Sets the attribute debug
    #
    # @param value the value to set the attribute debug to.
    #
    # source://rr//lib/rr/without_autohook.rb#115
    def debug=(_arg0); end

    # Returns the value of attribute debug.
    #
    # source://rr//lib/rr/without_autohook.rb#115
    def debug?; end

    # source://rr//lib/rr/integrations.rb#33
    def find_applicable_adapter(name); end

    # source://rr//lib/rr/integrations.rb#23
    def loaded_adapter_names; end

    # source://rr//lib/rr/integrations.rb#39
    def module_shim_for_adapter(adapter); end

    # source://rr//lib/rr/without_autohook.rb#109
    def ordered_doubles(*args, &block); end

    # Returns the value of attribute overridden_error_class.
    #
    # source://rr//lib/rr/errors.rb#3
    def overridden_error_class; end

    # Sets the attribute overridden_error_class
    #
    # @param value the value to set the attribute overridden_error_class to.
    #
    # source://rr//lib/rr/errors.rb#3
    def overridden_error_class=(_arg0); end

    # source://rr//lib/rr/without_autohook.rb#109
    def record_call(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def recorded_calls(*args, &block); end

    # source://rr//lib/rr/integrations.rb#7
    def register_adapter(klass); end

    # source://rr//lib/rr/without_autohook.rb#109
    def register_ordered_double(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def reset(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def reset_bound_objects(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def reset_double(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def reset_method_missing_injections(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def reset_ordered_doubles(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def reset_recorded_calls(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def reset_singleton_method_added_injections(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def trim_backtrace(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def trim_backtrace=(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def verify(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def verify_double(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def verify_doubles(*args, &block); end

    # source://rr//lib/rr/without_autohook.rb#109
    def verify_ordered_double(*args, &block); end

    # source://rr//lib/rr/version.rb#3
    def version; end
  end
end

# source://rr//lib/rr/deprecations.rb#2
module RR::Adapters; end

# People who manually include RR into their test framework will use
# these constants
#
# source://rr//lib/rr/deprecations.rb#6
module RR::Adapters::MiniTest
  class << self
    # @private
    #
    # source://rr//lib/rr/deprecations.rb#7
    def included(base); end
  end
end

# source://rr//lib/rr/deprecations.rb#43
module RR::Adapters::RRMethods
  include ::RR::DoubleDefinitions::Strategies::StrategyMethods
  include ::RR::DSL

  class << self
    # @private
    #
    # source://rr//lib/rr/deprecations.rb#46
    def included(base); end
  end
end

# source://rr//lib/rr/deprecations.rb#20
module RR::Adapters::RSpec2
  class << self
    # @private
    #
    # source://rr//lib/rr/deprecations.rb#21
    def included(base); end
  end
end

# source://rr//lib/rr/deprecations.rb#27
module RR::Adapters::Rspec
  class << self
    # source://rr//lib/rr/deprecations.rb#28
    def const_missing(name); end
  end
end

# source://rr//lib/rr/deprecations.rb#13
module RR::Adapters::TestUnit
  class << self
    # @private
    #
    # source://rr//lib/rr/deprecations.rb#14
    def included(base); end
  end
end

# source://rr//lib/rr/blank_slate.rb#2
module RR::BlankSlate; end

# source://rr//lib/rr/class_instance_method_defined.rb#2
module RR::ClassInstanceMethodDefined
  # source://rr//lib/rr/class_instance_method_defined.rb#3
  def class_instance_method_defined(klass, instance_method, include_super = T.unsafe(nil)); end
end

# source://rr//lib/rr/dsl.rb#2
module RR::DSL
  include ::RR::DoubleDefinitions::Strategies::StrategyMethods

  # source://rr//lib/rr/dsl.rb#50
  def any_instance_of(*args, &block); end

  # Returns a AnyTimesMatcher. This is meant to be passed in as an argument
  # to Double#times.
  #
  #   mock(object).method_name(anything).times(any_times) {return_value}
  #
  # source://rr//lib/rr/dsl.rb#69
  def any_times; end

  # Sets up an Anything wildcard ArgumentEqualityExpectation
  # that succeeds when passed any argument.
  #   mock(object).method_name(anything) {return_value}
  #   object.method_name("an arbitrary value") # passes
  #
  # source://rr//lib/rr/dsl.rb#77
  def anything; end

  # Sets up an Boolean wildcard ArgumentEqualityExpectation
  # that succeeds when passed an argument that is a ::Boolean.
  #   mock(object).method_name(boolean) {return_value}
  #   object.method_name(false) # passes
  #
  # source://rr//lib/rr/dsl.rb#101
  def boolean; end

  # source://rr//lib/rr/dsl.rb#30
  def dont_allow(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # Sets up a DuckType wildcard ArgumentEqualityExpectation
  # that succeeds when the passed argument implements the methods.
  #   arg = Object.new
  #   def arg.foo; end
  #   def arg.bar; end
  #   mock(object).method_name(duck_type(:foo, :bar)) {return_value}
  #   object.method_name(arg) # passes
  #
  # source://rr//lib/rr/dsl.rb#112
  def duck_type(*args); end

  # Sets up a HashIncluding wildcard ArgumentEqualityExpectation
  # that succeeds when the passed argument contains at least those keys
  # and values of the expectation.
  #   mock(object).method_name(hash_including(:foo => 1)) {return_value}
  #   object.method_name({:foo => 1, :bar => 2) # passes
  #
  # source://rr//lib/rr/dsl.rb#121
  def hash_including(expected_hash); end

  # source://rr//lib/rr/dsl.rb#45
  def instance_of(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # Sets up an IsA wildcard ArgumentEqualityExpectation
  # that succeeds when passed an argument of a certain type.
  #   mock(object).method_name(is_a(String)) {return_value}
  #   object.method_name("A String") # passes
  #
  # source://rr//lib/rr/dsl.rb#85
  def is_a(klass); end

  # source://rr//lib/rr/dsl.rb#20
  def mock(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # Sets up an Numeric wildcard ArgumentEqualityExpectation
  # that succeeds when passed an argument that is ::Numeric.
  #   mock(object).method_name(numeric) {return_value}
  #   object.method_name(99) # passes
  #
  # source://rr//lib/rr/dsl.rb#93
  def numeric; end

  # source://rr//lib/rr/dsl.rb#35
  def proxy(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/dsl.rb#144
  def received(subject); end

  # Resets the registered Doubles and ordered Doubles
  #
  # source://rr//lib/rr/dsl.rb#61
  def reset; end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#8
  def rr_all_instances_of(*args, &block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#8
  def rr_all_instances_of!(*args, &block); end

  # source://rr//lib/rr/dsl.rb#50
  def rr_any_instance_of(*args, &block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#39
  def rr_any_instance_of!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/dsl.rb#69
  def rr_any_times; end

  # source://rr//lib/rr/dsl.rb#77
  def rr_anything; end

  # source://rr//lib/rr/dsl.rb#101
  def rr_boolean; end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#8
  def rr_do_not_allow(*args, &block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#8
  def rr_do_not_allow!(*args, &block); end

  # source://rr//lib/rr/dsl.rb#30
  def rr_dont_allow(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#23
  def rr_dont_allow!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/dsl.rb#112
  def rr_duck_type(*args); end

  # source://rr//lib/rr/dsl.rb#121
  def rr_hash_including(expected_hash); end

  # source://rr//lib/rr/dsl.rb#45
  def rr_instance_of(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#43
  def rr_instance_of!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/dsl.rb#85
  def rr_is_a(klass); end

  # source://rr//lib/rr/dsl.rb#20
  def rr_mock(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#15
  def rr_mock!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/dsl.rb#93
  def rr_numeric; end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#8
  def rr_probe(*args, &block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#8
  def rr_probe!(*args, &block); end

  # source://rr//lib/rr/dsl.rb#35
  def rr_proxy(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#29
  def rr_proxy!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/dsl.rb#144
  def rr_received(subject); end

  # source://rr//lib/rr/dsl.rb#61
  def rr_reset; end

  # source://rr//lib/rr/dsl.rb#130
  def rr_satisfy(expectation_proc = T.unsafe(nil), &block); end

  # source://rr//lib/rr/dsl.rb#135
  def rr_spy(subject); end

  # source://rr//lib/rr/dsl.rb#40
  def rr_strong(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#35
  def rr_strong!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/dsl.rb#25
  def rr_stub(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#19
  def rr_stub!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/dsl.rb#56
  def rr_verify; end

  # Sets up a Satisfy wildcard ArgumentEqualityExpectation
  # that succeeds when the passed argument causes the expectation's
  # proc to return true.
  #   mock(object).method_name(satisfy {|arg| arg == :foo}) {return_value}
  #   object.method_name(:foo) # passes
  #
  # source://rr//lib/rr/dsl.rb#130
  def satisfy(expectation_proc = T.unsafe(nil), &block); end

  # source://rr//lib/rr/dsl.rb#135
  def spy(subject); end

  # source://rr//lib/rr/dsl.rb#40
  def strong(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/dsl.rb#25
  def stub(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # Verifies all the DoubleInjection objects have met their
  # TimesCalledExpectations.
  #
  # source://rr//lib/rr/dsl.rb#56
  def verify; end
end

# source://rr//lib/rr/dsl.rb#3
RR::DSL::METHODS_TO_EXCLUDE_FROM_SPYING = T.let(T.unsafe(nil), Array)

# source://rr//lib/rr/deprecations.rb#68
module RR::Deprecations
  class << self
    # source://rr//lib/rr/deprecations.rb#85
    def constant_deprecated_in_favor_of(old_name, new_name); end

    # source://rr//lib/rr/deprecations.rb#69
    def show_warning(msg, options = T.unsafe(nil)); end

    # source://rr//lib/rr/deprecations.rb#90
    def show_warning_for_deprecated_adapter; end
  end
end

# RR::Double is the use case for a method call.
# It has the ArgumentEqualityExpectation, TimesCalledExpectation,
# and the implementation.
#
# source://rr//lib/rr/double.rb#5
class RR::Double
  include ::RR::Space::Reader

  # @return [Double] a new instance of Double
  #
  # source://rr//lib/rr/double.rb#29
  def initialize(double_injection, definition); end

  # Double#attempt? returns true when the
  # TimesCalledExpectation is satisfied.
  #
  # @return [Boolean]
  #
  # source://rr//lib/rr/double.rb#53
  def attempt?; end

  # Returns the value of attribute definition.
  #
  # source://rr//lib/rr/double.rb#25
  def definition; end

  # Returns the value of attribute double_injection.
  #
  # source://rr//lib/rr/double.rb#25
  def double_injection; end

  # Double#exact_match? returns true when the passed in arguments
  # exactly match the ArgumentEqualityExpectation arguments.
  #
  # @return [Boolean]
  #
  # source://rr//lib/rr/double.rb#41
  def exact_match?(arguments, keyword_arguments); end

  # The Arguments that this Double expects
  #
  # source://rr//lib/rr/double.rb#78
  def expected_arguments; end

  # The keyword arguments that this Double expects
  #
  # source://rr//lib/rr/double.rb#84
  def expected_keyword_arguments; end

  # source://rr//lib/rr/double.rb#94
  def formatted_name; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/double.rb#108
  def implementation_is_original_method?; end

  # source://rr//lib/rr/double.rb#100
  def method_call(args, kwargs); end

  # The method name that this Double is attatched to
  #
  # source://rr//lib/rr/double.rb#73
  def method_name; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/double.rb#67
  def terminal?; end

  # Returns the value of attribute times_called.
  #
  # source://rr//lib/rr/double.rb#25
  def times_called; end

  # Returns the value of attribute times_called_expectation.
  #
  # source://rr//lib/rr/double.rb#25
  def times_called_expectation; end

  # The TimesCalledMatcher for the TimesCalledExpectation
  #
  # source://rr//lib/rr/double.rb#90
  def times_matcher; end

  # Double#verify verifies the the TimesCalledExpectation
  # is satisfied for this double. A TimesCalledError
  # is raised if the TimesCalledExpectation is not met.
  #
  # source://rr//lib/rr/double.rb#61
  def verify; end

  # Double#wildcard_match? returns true when the passed in arguments
  # wildcard match the ArgumentEqualityExpectation arguments.
  #
  # @return [Boolean]
  #
  # source://rr//lib/rr/double.rb#47
  def wildcard_match?(arguments, keyword_arguments); end

  protected

  # source://rr//lib/rr/double.rb#161
  def args; end

  # source://rr//lib/rr/double.rb#169
  def argument_expectation; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/double.rb#152
  def arity_matches?; end

  # source://rr//lib/rr/double.rb#165
  def kwargs; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/double.rb#113
  def ordered?; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/double.rb#144
  def subject_accepts_only_varargs?; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/double.rb#148
  def subject_accepts_varargs?; end

  # source://rr//lib/rr/double.rb#140
  def subject_arity; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/double.rb#117
  def verbose?; end

  # source://rr//lib/rr/double.rb#127
  def verify_argument_expectation_is_set; end

  # source://rr//lib/rr/double.rb#133
  def verify_method_signature; end

  # source://rr//lib/rr/double.rb#121
  def verify_times_matcher_is_set; end
end

# source://rr//lib/rr/double_definitions/strategies/strategy.rb#2
module RR::DoubleDefinitions; end

# :nodoc
#
# source://rr//lib/rr/double_definitions/child_double_definition_create.rb#3
class RR::DoubleDefinitions::ChildDoubleDefinitionCreate < ::RR::DoubleDefinitions::DoubleDefinitionCreate
  # @return [ChildDoubleDefinitionCreate] a new instance of ChildDoubleDefinitionCreate
  #
  # source://rr//lib/rr/double_definitions/child_double_definition_create.rb#6
  def initialize(parent_double_definition); end

  # @raise [NoMethodError]
  #
  # source://rr//lib/rr/double_definitions/child_double_definition_create.rb#15
  def instance_of(*args); end

  # Returns the value of attribute parent_double_definition.
  #
  # source://rr//lib/rr/double_definitions/child_double_definition_create.rb#4
  def parent_double_definition; end

  # source://rr//lib/rr/double_definitions/child_double_definition_create.rb#11
  def root_subject; end

  protected

  # source://rr//lib/rr/double_definitions/child_double_definition_create.rb#20
  def add_strategy(subject, method_name, definition_eval_block, &block); end
end

# source://rr//lib/rr/double_definitions/double_definition.rb#3
class RR::DoubleDefinitions::DoubleDefinition
  include ::RR::Space::Reader
  include ::RR::DoubleDefinitions::DoubleDefinition::ArgumentDefinitionConstructionMethods
  include ::RR::DoubleDefinitions::DoubleDefinition::TimesDefinitionConstructionMethods
  include ::RR::DoubleDefinitions::DoubleDefinition::DefinitionConstructionMethods
  include ::RR::DoubleDefinitions::DoubleDefinition::StateQueryMethods
  include ::RR::DoubleDefinitions::Strategies::StrategyMethods

  # @return [DoubleDefinition] a new instance of DoubleDefinition
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#18
  def initialize(double_definition_create); end

  # Returns the value of attribute after_call_proc.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def after_call_proc; end

  # Sets the attribute after_call_proc
  #
  # @param value the value to set the attribute after_call_proc to.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def after_call_proc=(_arg0); end

  # source://rr//lib/rr/double_definitions/double_definition.rb#387
  def any_instance_of(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # Returns the value of attribute argument_expectation.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def argument_expectation; end

  # Sets the attribute argument_expectation
  #
  # @param value the value to set the attribute argument_expectation to.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def argument_expectation=(_arg0); end

  # source://rr//lib/rr/double_definitions/double_definition.rb#375
  def dont_allow(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # Returns the value of attribute double.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def double; end

  # Sets the attribute double
  #
  # @param value the value to set the attribute double to.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def double=(_arg0); end

  # Returns the value of attribute double_definition_create.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def double_definition_create; end

  # Sets the attribute double_definition_create
  #
  # @param value the value to set the attribute double_definition_create to.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def double_definition_create=(_arg0); end

  # Returns the value of attribute implementation.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def implementation; end

  # Sets the attribute implementation
  #
  # @param value the value to set the attribute implementation to.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def implementation=(_arg0); end

  # source://rr//lib/rr/double_definitions/double_definition.rb#391
  def instance_of(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition.rb#367
  def mock(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition.rb#379
  def proxy(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition.rb#34
  def root_subject; end

  # source://rr//lib/rr/double_definitions/double_definition.rb#383
  def strong(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition.rb#371
  def stub(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition.rb#30
  def subject; end

  # Returns the value of attribute times_matcher.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def times_matcher; end

  # Sets the attribute times_matcher
  #
  # @param value the value to set the attribute times_matcher to.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def times_matcher=(_arg0); end

  # Returns the value of attribute yields_value.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def yields_value; end

  # Sets the attribute yields_value
  #
  # @param value the value to set the attribute yields_value to.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#6
  def yields_value=(_arg0); end
end

# source://rr//lib/rr/double_definitions/double_definition.rb#38
module RR::DoubleDefinitions::DoubleDefinition::ArgumentDefinitionConstructionMethods
  # Double#with sets the expectation that the Double will receive
  # the passed in arguments.
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.with(1, 2) {:return_value}
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#46
  def with(*args, **kwargs, &return_value_block); end

  # Double#with_any_args sets the expectation that the Double can receive
  # any arguments.
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.with_any_args {:return_value}
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#67
  def with_any_args(&return_value_block); end

  # Double#with_no_args sets the expectation that the Double will receive
  # no arguments.
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.with_no_args {:return_value}
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#79
  def with_no_args(&return_value_block); end
end

# source://rr//lib/rr/double_definitions/double_definition.rb#178
module RR::DoubleDefinitions::DoubleDefinition::DefinitionConstructionMethods
  # Double#after_call creates a callback that occurs after call
  # is called. The passed in block receives the return value of
  # the Double being called.
  # An Expection will be raised if no block is passed in.
  #
  #   mock(subject).method_name {return_value}.after_call {|return_value|}
  #   subject.method_name # return_value
  #
  # This feature is built into proxies.
  #   mock.proxy(User).find('1') {|user| mock(user).valid? {false}}
  #
  # @raise [ArgumentError]
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#224
  def after_call(&after_call_proc); end

  # Double#implemented_by sets the implementation of the Double.
  # This method takes a Proc or a Method. Passing in a Method allows
  # the Double to accept blocks.
  #
  #   obj = Object.new
  #   def obj.foobar
  #     yield(1)
  #   end
  #   mock(obj).method_name.implemented_by(obj.method(:foobar))
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#274
  def implemented_by(implementation); end

  # source://rr//lib/rr/double_definitions/double_definition.rb#260
  def implemented_by_original_method; end

  # Double#ordered sets the Double to have an ordered
  # expectation.
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.ordered {return_value}
  #
  # @raise [Errors::DoubleDefinitionError]
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#185
  def ordered(&return_value_block); end

  # Double#returns accepts an argument value or a block.
  # It will raise an ArgumentError if both are passed in.
  #
  # Passing in a block causes Double to return the return value of
  # the passed in block.
  #
  # Passing in an argument causes Double to return the argument.
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#246
  def returns(*args, &implementation); end

  # source://rr//lib/rr/double_definitions/double_definition.rb#279
  def strong; end

  # Double#ordered sets the Double to have an ordered
  # expectation.
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.ordered {return_value}
  #
  # @raise [Errors::DoubleDefinitionError]
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#185
  def then(&return_value_block); end

  # Double#verbose sets the Double to print out each method call it receives.
  #
  # Passing in a block sets the return value
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#233
  def verbose(&after_call_proc); end

  # source://rr//lib/rr/double_definitions/double_definition.rb#279
  def verify_method_signature; end

  # Double#yields sets the Double to invoke a passed in block when
  # the Double is called.
  # An Expection will be raised if no block is passed in when the
  # Double is called.
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.yields(yield_arg1, yield_arg2) {return_value}
  #   subject.method_name {|yield_arg1, yield_arg2|}
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#208
  def yields(*args, &return_value_block); end

  protected

  # source://rr//lib/rr/double_definitions/double_definition.rb#286
  def install_method_callback(block); end
end

# source://rr//lib/rr/double_definitions/double_definition.rb#4
RR::DoubleDefinitions::DoubleDefinition::ORIGINAL_METHOD = T.let(T.unsafe(nil), Object)

# source://rr//lib/rr/double_definitions/double_definition.rb#298
module RR::DoubleDefinitions::DoubleDefinition::StateQueryMethods
  # @return [Boolean]
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#312
  def exact_match?(arguments, keyword_arguments); end

  # source://rr//lib/rr/double_definitions/double_definition.rb#333
  def expected_arguments; end

  # source://rr//lib/rr/double_definitions/double_definition.rb#341
  def expected_keyword_arguments; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#349
  def implementation_is_original_method?; end

  # Double#ordered? returns true when the Double is ordered.
  #
  #   mock(subject).method_name.ordered?
  #
  # @return [Boolean]
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#302
  def ordered?; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#353
  def strong?; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#326
  def terminal?; end

  # Double#verbose? returns true when verbose has been called on it. It returns
  # true when the double is set to print each method call it receives.
  #
  # @return [Boolean]
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#308
  def verbose?; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#353
  def verify_method_signature?; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#319
  def wildcard_match?(arguments, keyword_arguments); end

  protected

  # source://rr//lib/rr/double_definitions/double_definition.rb#359
  def implementation_strategy; end
end

# source://rr//lib/rr/double_definitions/double_definition.rb#88
module RR::DoubleDefinitions::DoubleDefinition::TimesDefinitionConstructionMethods
  # Double#any_number_of_times sets an that the Double will be called
  # any number of times. This effectively removes the times called expectation
  # from the Doublen
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.any_number_of_times
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#157
  def any_number_of_times(&return_value_block); end

  # Double#any_number_of_times sets an that the Double will be called
  # any number of times. This effectively removes the times called expectation
  # from the Doublen
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.any_number_of_times
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#157
  def any_times(&return_value_block); end

  # Double#at_least sets the expectation that the Double
  # will be called at least n times.
  # It works by creating a TimesCalledExpectation.
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.at_least(4) {:return_value}
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#131
  def at_least(number, &return_value_block); end

  # Double#at_most allows sets the expectation that the Double
  # will be called at most n times.
  # It works by creating a TimesCalledExpectation.
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.at_most(4) {:return_value}
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#144
  def at_most(number, &return_value_block); end

  # Double#never sets the expectation that the Double will never be
  # called.
  #
  # This method does not accept a block because it will never be called.
  #
  #   mock(subject).method_name.never
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#95
  def never; end

  # Double#once sets the expectation that the Double will be called
  # 1 time.
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.once {:return_value}
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#106
  def once(&return_value_block); end

  # Double#times creates an TimesCalledExpectation of the passed
  # in number.
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.times(4) {:return_value}
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#170
  def times(matcher_value, &return_value_block); end

  # Double#twice sets the expectation that the Double will be called
  # 2 times.
  #
  # Passing in a block sets the return value.
  #
  #   mock(subject).method_name.twice {:return_value}
  #
  # source://rr//lib/rr/double_definitions/double_definition.rb#118
  def twice(&return_value_block); end
end

# :nodoc
#
# source://rr//lib/rr/double_definitions/double_definition_create.rb#3
class RR::DoubleDefinitions::DoubleDefinitionCreate
  include ::RR::Space::Reader
  include ::RR::DoubleDefinitions::DoubleDefinitionCreate::StrategySetupMethods
  include ::RR::DoubleDefinitions::Strategies::StrategyMethods

  # @return [DoubleDefinitionCreate] a new instance of DoubleDefinitionCreate
  #
  # source://rr//lib/rr/double_definitions/double_definition_create.rb#27
  def initialize; end

  # DoubleInjection Strategies
  #
  # source://rr//lib/rr/double_definitions/double_definition_create.rb#136
  def all_instances_of(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # DoubleInjection Strategies
  #
  # source://rr//lib/rr/double_definitions/double_definition_create.rb#136
  def any_instance_of(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#33
  def call(method_name, args, kwargs, &handler); end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#120
  def dont_allow(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # Returns the value of attribute double_injection_strategy.
  #
  # source://rr//lib/rr/double_definitions/double_definition_create.rb#22
  def double_injection_strategy; end

  # Returns the value of attribute implementation_strategy.
  #
  # source://rr//lib/rr/double_definitions/double_definition_create.rb#22
  def implementation_strategy; end

  # DoubleInjection Strategies
  #
  # source://rr//lib/rr/double_definitions/double_definition_create.rb#136
  def instance_of(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#45
  def method_name; end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#112
  def mock(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # Implementation Strategies
  #
  # source://rr//lib/rr/double_definitions/double_definition_create.rb#126
  def proxy(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#41
  def root_subject; end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#130
  def strong(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#116
  def stub(subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # Returns the value of attribute subject.
  #
  # source://rr//lib/rr/double_definitions/double_definition_create.rb#22
  def subject; end

  # Returns the value of attribute verification_strategy.
  #
  # source://rr//lib/rr/double_definitions/double_definition_create.rb#22
  def verification_strategy; end
end

# source://rr//lib/rr/double_definitions/double_definition_create.rb#105
class RR::DoubleDefinitions::DoubleDefinitionCreate::DoubleDefinitionCreateError < ::RR::Errors::RRError; end

# source://rr//lib/rr/double_definitions/double_definition_create.rb#23
RR::DoubleDefinitions::DoubleDefinitionCreate::NO_SUBJECT = T.let(T.unsafe(nil), Object)

# source://rr//lib/rr/double_definitions/double_definition_create.rb#49
module RR::DoubleDefinitions::DoubleDefinitionCreate::StrategySetupMethods
  # @return [Boolean]
  #
  # source://rr//lib/rr/double_definitions/double_definition_create.rb#50
  def no_subject?; end

  protected

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#67
  def add_double_injection_strategy(double_injection_strategy_class, subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#61
  def add_implementation_strategy(implementation_strategy_class, subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#73
  def add_strategy(subject, method_name, definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#55
  def add_verification_strategy(verification_strategy_class, subject = T.unsafe(nil), method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#99
  def double_injection_strategy=(double_injection_strategy); end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#95
  def implementation_strategy=(implementation_strategy); end

  # source://rr//lib/rr/double_definitions/double_definition_create.rb#90
  def verification_strategy=(verification_strategy); end
end

# source://rr//lib/rr/double_definitions/double_definition_create_blank_slate.rb#3
class RR::DoubleDefinitions::DoubleDefinitionCreateBlankSlate
  # @return [DoubleDefinitionCreateBlankSlate] a new instance of DoubleDefinitionCreateBlankSlate
  #
  # source://rr//lib/rr/double_definitions/double_definition_create_blank_slate.rb#4
  def initialize(double_definition_create, &block); end

  # source://rr//lib/rr/double_definitions/double_definition_create_blank_slate.rb#28
  def __double_definition_create__; end

  # source://rr//lib/rr/double_definitions/double_definition_create_blank_slate.rb#18
  def method_missing(method_name, *args, **kwargs, &block); end
end

# source://rr//lib/rr/double_definitions/double_injections/instance.rb#3
module RR::DoubleDefinitions::DoubleInjections; end

# source://rr//lib/rr/double_definitions/double_injections/any_instance_of.rb#4
class RR::DoubleDefinitions::DoubleInjections::AnyInstanceOf
  extend ::RR::DoubleDefinitions::Strategies::StrategyMethods
  extend ::RR::DSL
end

# source://rr//lib/rr/double_definitions/double_injections/instance.rb#4
class RR::DoubleDefinitions::DoubleInjections::Instance
  extend ::RR::DoubleDefinitions::Strategies::StrategyMethods
  extend ::RR::DSL
end

# source://rr//lib/rr/double_definitions/strategies/strategy.rb#3
module RR::DoubleDefinitions::Strategies; end

# source://rr//lib/rr/double_definitions/strategies/double_injection/double_injection_strategy.rb#4
module RR::DoubleDefinitions::Strategies::DoubleInjection; end

# This class is Deprecated.
# Calling instance_of will cause all instances of the passed in Class
# to have the Double defined.
#
# The following example mocks all User's valid? method and return false.
#   mock.instance_of(User).valid? {false}
#
# The following example mocks and proxies User#projects and returns the
# first 3 projects.
#   mock.instance_of(User).projects do |projects|
#     projects[0..2]
#   end
#
# source://rr//lib/rr/double_definitions/strategies/double_injection/any_instance_of.rb#17
class RR::DoubleDefinitions::Strategies::DoubleInjection::AnyInstanceOf < ::RR::DoubleDefinitions::Strategies::DoubleInjection::DoubleInjectionStrategy
  protected

  # source://rr//lib/rr/double_definitions/strategies/double_injection/any_instance_of.rb#19
  def do_call; end
end

# source://rr//lib/rr/double_definitions/strategies/double_injection/double_injection_strategy.rb#5
class RR::DoubleDefinitions::Strategies::DoubleInjection::DoubleInjectionStrategy < ::RR::DoubleDefinitions::Strategies::Strategy; end

# source://rr//lib/rr/double_definitions/strategies/double_injection/instance.rb#5
class RR::DoubleDefinitions::Strategies::DoubleInjection::Instance < ::RR::DoubleDefinitions::Strategies::DoubleInjection::DoubleInjectionStrategy
  protected

  # source://rr//lib/rr/double_definitions/strategies/double_injection/instance.rb#7
  def do_call; end
end

# source://rr//lib/rr/double_definitions/strategies/implementation/implementation_strategy.rb#4
module RR::DoubleDefinitions::Strategies::Implementation; end

# source://rr//lib/rr/double_definitions/strategies/implementation/implementation_strategy.rb#5
class RR::DoubleDefinitions::Strategies::Implementation::ImplementationStrategy < ::RR::DoubleDefinitions::Strategies::Strategy; end

# This method add proxy capabilities to the Double. proxy can be called
# with mock or stub.
#
#   mock.proxy(controller.template).render(:partial => "my/socks")
#
#   stub.proxy(controller.template).render(:partial => "my/socks") do |html|
#     html.should include("My socks are wet")
#     html
#   end
#
#   mock.proxy(controller.template).render(:partial => "my/socks") do |html|
#     html.should include("My socks are wet")
#     "My new return value"
#   end
#
# mock.proxy also takes a block for definitions.
#   mock.proxy(subject) do
#     render(:partial => "my/socks")
#
#     render(:partial => "my/socks") do |html|
#       html.should include("My socks are wet")
#       html
#     end
#
#     render(:partial => "my/socks") do |html|
#       html.should include("My socks are wet")
#       html
#     end
#
#     render(:partial => "my/socks") do |html|
#       html.should include("My socks are wet")
#       "My new return value"
#     end
#   end
#
# Passing a block to the Double (after the method name and arguments)
# allows you to intercept the return value.
# The return value can be modified, validated, and/or overridden by
# passing in a block. The return value of the block will replace
# the actual return value.
#
#   mock.proxy(controller.template).render(:partial => "my/socks") do |html|
#     html.should include("My socks are wet")
#     "My new return value"
#   end
#
# source://rr//lib/rr/double_definitions/strategies/implementation/proxy.rb#50
class RR::DoubleDefinitions::Strategies::Implementation::Proxy < ::RR::DoubleDefinitions::Strategies::Implementation::ImplementationStrategy
  protected

  # source://rr//lib/rr/double_definitions/strategies/implementation/proxy.rb#52
  def do_call; end
end

# source://rr//lib/rr/double_definitions/strategies/implementation/reimplementation.rb#5
class RR::DoubleDefinitions::Strategies::Implementation::Reimplementation < ::RR::DoubleDefinitions::Strategies::Implementation::ImplementationStrategy
  protected

  # source://rr//lib/rr/double_definitions/strategies/implementation/reimplementation.rb#7
  def do_call; end
end

# source://rr//lib/rr/double_definitions/strategies/implementation/strongly_typed_reimplementation.rb#5
class RR::DoubleDefinitions::Strategies::Implementation::StronglyTypedReimplementation < ::RR::DoubleDefinitions::Strategies::Implementation::Reimplementation
  protected

  # source://rr//lib/rr/double_definitions/strategies/implementation/strongly_typed_reimplementation.rb#7
  def do_call; end
end

# source://rr//lib/rr/double_definitions/strategies/strategy.rb#4
class RR::DoubleDefinitions::Strategies::Strategy
  include ::RR::Space::Reader

  # @return [Strategy] a new instance of Strategy
  #
  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#14
  def initialize(double_definition_create); end

  # Returns the value of attribute args.
  #
  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#8
  def args; end

  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#18
  def call(definition, method_name, args, kwargs, handler); end

  # Returns the value of attribute definition.
  #
  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#6
  def definition; end

  # Returns the value of attribute double_definition_create.
  #
  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#5
  def double_definition_create; end

  # Returns the value of attribute handler.
  #
  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#10
  def handler; end

  # Returns the value of attribute kwargs.
  #
  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#9
  def kwargs; end

  # Returns the value of attribute method_name.
  #
  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#7
  def method_name; end

  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#27
  def verify_subject(subject); end

  protected

  # @raise [NotImplementedError]
  #
  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#31
  def do_call; end

  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#36
  def permissive_argument; end

  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#53
  def reimplementation; end

  # source://rr//lib/rr/double_definitions/strategies/strategy.rb#57
  def subject; end
end

# source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#4
module RR::DoubleDefinitions::Strategies::StrategyMethods
  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#8
  def all_instances_of(*args, &block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#8
  def all_instances_of!(*args, &block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#39
  def any_instance_of!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#8
  def do_not_allow(*args, &block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#8
  def do_not_allow!(*args, &block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#23
  def dont_allow!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#43
  def instance_of!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#15
  def mock!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#8
  def probe(*args, &block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#8
  def probe!(*args, &block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#29
  def proxy!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#35
  def strong!(method_name = T.unsafe(nil), &definition_eval_block); end

  # source://rr//lib/rr/double_definitions/strategies/strategy_methods.rb#19
  def stub!(method_name = T.unsafe(nil), &definition_eval_block); end
end

# source://rr//lib/rr/double_definitions/strategies/verification/verification_strategy.rb#4
module RR::DoubleDefinitions::Strategies::Verification; end

# This method sets the Double to have a dont_allow strategy.
# A dont_allow strategy sets the default state of the Double
# to expect never to be called. The Double's expectations can be
# changed.
#
# The following example sets the expectation that subject.method_name
# will never be called with arg1 and arg2.
#
#   do_not_allow(subject).method_name(arg1, arg2)
#
# dont_allow also supports a block sytnax.
#    dont_allow(subject) do |m|
#      m.method1 # Do not allow method1 with any arguments
#      m.method2(arg1, arg2) # Do not allow method2 with arguments arg1 and arg2
#      m.method3.with_no_args # Do not allow method3 with no arguments
#    end
#
# source://rr//lib/rr/double_definitions/strategies/verification/dont_allow.rb#21
class RR::DoubleDefinitions::Strategies::Verification::DontAllow < ::RR::DoubleDefinitions::Strategies::Verification::VerificationStrategy
  protected

  # source://rr//lib/rr/double_definitions/strategies/verification/dont_allow.rb#23
  def do_call; end
end

# This method sets the Double to have a mock strategy. A mock strategy
# sets the default state of the Double to expect the method call
# with arguments exactly one time. The Double's expectations can be
# changed.
#
# This method can be chained with proxy.
#   mock.proxy(subject).method_name_1
#   or
#   proxy.mock(subject).method_name_1
#
# When passed the subject, a DoubleDefinitionCreateBlankSlate is returned. Passing
# a method with arguments to the proxy will set up expectations that
# a call to the subject's method with the arguments will happen,
# and return the prescribed value.
#   mock(subject).method_name_1 {return_value_1}
#   mock(subject).method_name_2(arg1, arg2) {return_value_2}
#
# When passed the subject and the method_name, this method returns
# a mock Double with the method already set.
#
#   mock(subject, :method_name_1) {return_value_1}
#   mock(subject, :method_name_2).with(arg1, arg2) {return_value_2}
#
# mock also takes a block for definitions.
#   mock(subject) do
#     method_name_1 {return_value_1}
#     method_name_2(arg_1, arg_2) {return_value_2}
#   end
#
# source://rr//lib/rr/double_definitions/strategies/verification/mock.rb#33
class RR::DoubleDefinitions::Strategies::Verification::Mock < ::RR::DoubleDefinitions::Strategies::Verification::VerificationStrategy
  protected

  # source://rr//lib/rr/double_definitions/strategies/verification/mock.rb#36
  def do_call; end
end

# This method sets the Double to have a stub strategy. A stub strategy
# sets the default state of the Double to expect the method call
# with any arguments any number of times. The Double's
# expectations can be changed.
#
# This method can be chained with proxy.
#   stub.proxy(subject).method_name_1
#   or
#   proxy.stub(subject).method_name_1
#
# When passed the subject, a DoubleDefinitionCreateBlankSlate is returned. Passing
# a method with arguments to the proxy will set up expectations that
# the a call to the subject's method with the arguments will happen,
# and return the prescribed value.
#   stub(subject).method_name_1 {return_value_1}
#   stub(subject).method_name_2(arg_1, arg_2) {return_value_2}
#
# When passed the subject and the method_name, this method returns
# a stub Double with the method already set.
#
#   mock(subject, :method_name_1) {return_value_1}
#   mock(subject, :method_name_2).with(arg1, arg2) {return_value_2}
#
# stub also takes a block for definitions.
#   stub(subject) do
#     method_name_1 {return_value_1}
#     method_name_2(arg_1, arg_2) {return_value_2}
#   end
#
# source://rr//lib/rr/double_definitions/strategies/verification/stub.rb#33
class RR::DoubleDefinitions::Strategies::Verification::Stub < ::RR::DoubleDefinitions::Strategies::Verification::VerificationStrategy
  protected

  # source://rr//lib/rr/double_definitions/strategies/verification/stub.rb#35
  def do_call; end
end

# source://rr//lib/rr/double_definitions/strategies/verification/verification_strategy.rb#5
class RR::DoubleDefinitions::Strategies::Verification::VerificationStrategy < ::RR::DoubleDefinitions::Strategies::Strategy; end

# source://rr//lib/rr/double_matches.rb#2
class RR::DoubleMatches
  # @return [DoubleMatches] a new instance of DoubleMatches
  #
  # source://rr//lib/rr/double_matches.rb#9
  def initialize(doubles); end

  # Returns the value of attribute exact_non_terminal_doubles_to_attempt.
  #
  # source://rr//lib/rr/double_matches.rb#3
  def exact_non_terminal_doubles_to_attempt; end

  # Returns the value of attribute exact_terminal_doubles_to_attempt.
  #
  # source://rr//lib/rr/double_matches.rb#3
  def exact_terminal_doubles_to_attempt; end

  # source://rr//lib/rr/double_matches.rb#18
  def find_all_matches(args, kwargs); end

  # Returns the value of attribute matching_doubles.
  #
  # source://rr//lib/rr/double_matches.rb#3
  def matching_doubles; end

  # Returns the value of attribute wildcard_non_terminal_doubles_to_attempt.
  #
  # source://rr//lib/rr/double_matches.rb#3
  def wildcard_non_terminal_doubles_to_attempt; end

  # Returns the value of attribute wildcard_terminal_doubles_to_attempt.
  #
  # source://rr//lib/rr/double_matches.rb#3
  def wildcard_terminal_doubles_to_attempt; end
end

# source://rr//lib/rr/errors.rb#6
module RR::Errors
  class << self
    # source://rr//lib/rr/errors.rb#7
    def build_error(given_error, message = T.unsafe(nil), backtrace = T.unsafe(nil)); end

    # source://rr//lib/rr/errors.rb#14
    def error_class(given_error); end
  end
end

# source://rr//lib/rr/errors/rr_error.rb#3
RR::Errors::BACKTRACE_IDENTIFIER = T.let(T.unsafe(nil), Regexp)

# source://rr//lib/rr/errors/double_definition_error.rb#3
class RR::Errors::DoubleDefinitionError < ::RR::Errors::RRError; end

# source://rr//lib/rr/errors/double_not_found_error.rb#3
class RR::Errors::DoubleNotFoundError < ::RR::Errors::RRError; end

# source://rr//lib/rr/errors/double_order_error.rb#3
class RR::Errors::DoubleOrderError < ::RR::Errors::RRError; end

# source://rr//lib/rr/errors/rr_error.rb#5
class RR::Errors::RRError < ::RuntimeError
  # source://rr//lib/rr/errors/rr_error.rb#7
  def backtrace; end

  # Sets the attribute backtrace
  #
  # @param value the value to set the attribute backtrace to.
  #
  # source://rr//lib/rr/errors/rr_error.rb#6
  def backtrace=(_arg0); end
end

# source://rr//lib/rr/errors/spy_verification_errors/spy_verification_error.rb#3
module RR::Errors::SpyVerificationErrors; end

# source://rr//lib/rr/errors/spy_verification_errors/double_injection_not_found_error.rb#4
class RR::Errors::SpyVerificationErrors::DoubleInjectionNotFoundError < ::RR::Errors::SpyVerificationErrors::SpyVerificationError; end

# source://rr//lib/rr/errors/spy_verification_errors/invocation_count_error.rb#4
class RR::Errors::SpyVerificationErrors::InvocationCountError < ::RR::Errors::SpyVerificationErrors::SpyVerificationError; end

# source://rr//lib/rr/errors/spy_verification_errors/spy_verification_error.rb#4
class RR::Errors::SpyVerificationErrors::SpyVerificationError < ::RR::Errors::RRError; end

# source://rr//lib/rr/errors/subject_does_not_implement_method_error.rb#3
class RR::Errors::SubjectDoesNotImplementMethodError < ::RR::Errors::RRError; end

# source://rr//lib/rr/errors/subject_has_different_arity_error.rb#3
class RR::Errors::SubjectHasDifferentArityError < ::RR::Errors::RRError; end

# source://rr//lib/rr/errors/times_called_error.rb#3
class RR::Errors::TimesCalledError < ::RR::Errors::RRError; end

# source://rr//lib/rr/expectations/argument_equality_expectation.rb#2
module RR::Expectations; end

# source://rr//lib/rr/expectations/any_argument_expectation.rb#3
class RR::Expectations::AnyArgumentExpectation < ::RR::Expectations::ArgumentEqualityExpectation
  # @return [AnyArgumentExpectation] a new instance of AnyArgumentExpectation
  #
  # source://rr//lib/rr/expectations/any_argument_expectation.rb#4
  def initialize; end

  # source://rr//lib/rr/expectations/any_argument_expectation.rb#16
  def ==(other); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/expectations/any_argument_expectation.rb#8
  def exact_match?(arguments, keyword_arguments); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/expectations/any_argument_expectation.rb#12
  def wildcard_match?(arguments, keyword_arguments); end
end

# source://rr//lib/rr/expectations/argument_equality_expectation.rb#3
class RR::Expectations::ArgumentEqualityExpectation
  # @return [ArgumentEqualityExpectation] a new instance of ArgumentEqualityExpectation
  #
  # source://rr//lib/rr/expectations/argument_equality_expectation.rb#15
  def initialize(expected_arguments, expected_keyword_arguments); end

  # source://rr//lib/rr/expectations/argument_equality_expectation.rb#75
  def ==(other); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/expectations/argument_equality_expectation.rb#21
  def exact_match?(arguments, keyword_arguments); end

  # Returns the value of attribute expected_arguments.
  #
  # source://rr//lib/rr/expectations/argument_equality_expectation.rb#12
  def expected_arguments; end

  # Returns the value of attribute expected_keyword_arguments.
  #
  # source://rr//lib/rr/expectations/argument_equality_expectation.rb#13
  def expected_keyword_arguments; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/expectations/argument_equality_expectation.rb#43
  def wildcard_match?(arguments, keyword_arguments); end

  class << self
    # source://rr//lib/rr/expectations/argument_equality_expectation.rb#4
    def recursive_safe_eq(arg1, arg2); end
  end
end

# source://rr//lib/rr/expectations/times_called_expectation.rb#3
class RR::Expectations::TimesCalledExpectation
  # @return [TimesCalledExpectation] a new instance of TimesCalledExpectation
  #
  # source://rr//lib/rr/expectations/times_called_expectation.rb#6
  def initialize(double); end

  # source://rr//lib/rr/expectations/times_called_expectation.rb#16
  def attempt; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/expectations/times_called_expectation.rb#12
  def attempt?; end

  # Returns the value of attribute double.
  #
  # source://rr//lib/rr/expectations/times_called_expectation.rb#4
  def double; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/expectations/times_called_expectation.rb#33
  def terminal?; end

  # Returns the value of attribute times_called.
  #
  # source://rr//lib/rr/expectations/times_called_expectation.rb#4
  def times_called; end

  # source://rr//lib/rr/expectations/times_called_expectation.rb#22
  def verify; end

  # source://rr//lib/rr/expectations/times_called_expectation.rb#27
  def verify!; end

  protected

  # source://rr//lib/rr/expectations/times_called_expectation.rb#46
  def error_message; end

  # source://rr//lib/rr/expectations/times_called_expectation.rb#38
  def times_matcher; end

  # source://rr//lib/rr/expectations/times_called_expectation.rb#42
  def verify_input_error; end
end

# This is here because RSpec-2's RR adapters uses it
#
# source://rr//lib/rr/deprecations.rb#57
module RR::Extensions
  class << self
    # source://rr//lib/rr/deprecations.rb#58
    def const_missing(name); end
  end
end

# TODO: Refactor to a side-effect-free strategy.
#
# source://rr//lib/rr/hash_with_object_id_key.rb#3
class RR::HashWithObjectIdKey < ::Hash
  # @return [HashWithObjectIdKey] a new instance of HashWithObjectIdKey
  #
  # source://rr//lib/rr/hash_with_object_id_key.rb#4
  def initialize; end

  # source://rr//lib/rr/hash_with_object_id_key.rb#11
  def [](key); end

  # source://rr//lib/rr/hash_with_object_id_key.rb#22
  def []=(key, value); end

  # source://rr//lib/rr/hash_with_object_id_key.rb#33
  def delete(key); end

  # source://rr//lib/rr/hash_with_object_id_key.rb#27
  def each; end

  def get_with_object_id(_arg0); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/hash_with_object_id_key.rb#16
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/hash_with_object_id_key.rb#42
  def include?(key); end

  # source://rr//lib/rr/hash_with_object_id_key.rb#38
  def keys; end

  def set_with_object_id(_arg0, _arg1); end
end

# source://rr//lib/rr/injections/injection.rb#2
module RR::Injections; end

# RR::DoubleInjection is the binding of an subject and a method.
# A double_injection has 0 to many Double objects. Each Double
# has Argument Expectations and Times called Expectations.
#
# source://rr//lib/rr/injections/double_injection.rb#6
class RR::Injections::DoubleInjection < ::RR::Injections::Injection
  # @return [DoubleInjection] a new instance of DoubleInjection
  #
  # source://rr//lib/rr/injections/double_injection.rb#103
  def initialize(subject_class, method_name); end

  # RR::DoubleInjection#bind injects a method that acts as a dispatcher
  # that dispatches to the matching Double when the method
  # is called.
  #
  # source://rr//lib/rr/injections/double_injection.rb#119
  def bind; end

  # source://rr//lib/rr/injections/double_injection.rb#152
  def bind_method; end

  # source://rr//lib/rr/injections/double_injection.rb#136
  def bind_method_that_self_destructs_and_delegates_to_method_missing; end

  # source://rr//lib/rr/injections/double_injection.rb#215
  def dispatch_method(subject, args, kwargs, block); end

  # source://rr//lib/rr/injections/double_injection.rb#249
  def dispatch_method_delegates_to_dispatch_original_method; end

  # source://rr//lib/rr/injections/double_injection.rb#230
  def dispatch_original_method(subject, args, kwargs, block); end

  # Returns the value of attribute doubles.
  #
  # source://rr//lib/rr/injections/double_injection.rb#97
  def doubles; end

  # Returns the value of attribute method_name.
  #
  # source://rr//lib/rr/injections/double_injection.rb#97
  def method_name; end

  # source://rr//lib/rr/injections/double_injection.rb#245
  def original_method_alias_name; end

  # RR::DoubleInjection#register_double adds the passed in Double
  # into this DoubleInjection's list of Double objects.
  #
  # source://rr//lib/rr/injections/double_injection.rb#112
  def register_double(double); end

  # It binds the original method implementation on the subject
  # if one exists.
  #
  # source://rr//lib/rr/injections/double_injection.rb#203
  def reset; end

  # Returns the value of attribute subject_class.
  #
  # source://rr//lib/rr/injections/double_injection.rb#97
  def subject_class; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/injections/double_injection.rb#241
  def subject_has_original_method_missing?; end

  # RR::DoubleInjection#verify verifies each Double
  # TimesCalledExpectation are met.
  #
  # source://rr//lib/rr/injections/double_injection.rb#193
  def verify; end

  protected

  # source://rr//lib/rr/injections/double_injection.rb#265
  def bind_method_with_alias; end

  # source://rr//lib/rr/injections/double_injection.rb#257
  def deferred_bind_method; end
end

# source://rr//lib/rr/injections/double_injection.rb#134
RR::Injections::DoubleInjection::BoundObjects = T.let(T.unsafe(nil), Hash)

# source://rr//lib/rr/injections/double_injection.rb#99
class RR::Injections::DoubleInjection::MethodArguments < ::Struct
  # Returns the value of attribute arguments
  #
  # @return [Object] the current value of arguments
  def arguments; end

  # Sets the attribute arguments
  #
  # @param value [Object] the value to set the attribute arguments to.
  # @return [Object] the newly set value
  def arguments=(_); end

  # Returns the value of attribute block
  #
  # @return [Object] the current value of block
  def block; end

  # Sets the attribute block
  #
  # @param value [Object] the value to set the attribute block to.
  # @return [Object] the newly set value
  def block=(_); end

  # Returns the value of attribute keyword_arguments
  #
  # @return [Object] the current value of keyword_arguments
  def keyword_arguments; end

  # Sets the attribute keyword_arguments
  #
  # @param value [Object] the value to set the attribute keyword_arguments to.
  # @return [Object] the newly set value
  def keyword_arguments=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rr//lib/rr/injections/injection.rb#3
class RR::Injections::Injection
  include ::RR::Space::Reader
  include ::RR::ClassInstanceMethodDefined

  # source://rr//lib/rr/injections/injection.rb#21
  def original_method; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/injections/injection.rb#13
  def subject_has_method_defined?(method_name_in_question); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/injections/injection.rb#17
  def subject_has_original_method?; end

  protected

  # @return [Boolean]
  #
  # source://rr//lib/rr/injections/injection.rb#26
  def subject_respond_to_method?(subject, method_name); end
end

# source://rr//lib/rr/injections/method_missing_injection.rb#3
class RR::Injections::MethodMissingInjection < ::RR::Injections::Injection
  # @return [MethodMissingInjection] a new instance of MethodMissingInjection
  #
  # source://rr//lib/rr/injections/method_missing_injection.rb#22
  def initialize(subject_class); end

  # source://rr//lib/rr/injections/method_missing_injection.rb#27
  def bind; end

  # source://rr//lib/rr/injections/method_missing_injection.rb#55
  def reset; end

  # Returns the value of attribute subject_class.
  #
  # source://rr//lib/rr/injections/method_missing_injection.rb#20
  def subject_class; end

  protected

  # source://rr//lib/rr/injections/method_missing_injection.rb#70
  def bind_method; end

  # source://rr//lib/rr/injections/method_missing_injection.rb#114
  def original_method_alias_name; end
end

# source://rr//lib/rr/injections/method_missing_injection.rb#16
RR::Injections::MethodMissingInjection::BoundObjects = T.let(T.unsafe(nil), Hash)

# source://rr//lib/rr/injections/singleton_method_added_injection.rb#3
class RR::Injections::SingletonMethodAddedInjection < ::RR::Injections::Injection
  # @return [SingletonMethodAddedInjection] a new instance of SingletonMethodAddedInjection
  #
  # source://rr//lib/rr/injections/singleton_method_added_injection.rb#24
  def initialize(subject_class); end

  # source://rr//lib/rr/injections/singleton_method_added_injection.rb#29
  def bind; end

  # source://rr//lib/rr/injections/singleton_method_added_injection.rb#54
  def reset; end

  # Returns the value of attribute subject_class.
  #
  # source://rr//lib/rr/injections/singleton_method_added_injection.rb#22
  def subject_class; end

  protected

  # source://rr//lib/rr/injections/singleton_method_added_injection.rb#69
  def original_method_alias_name; end
end

# source://rr//lib/rr/integrations.rb#4
module RR::Integrations; end

# source://rr//lib/rr/integrations/decorator.rb#5
class RR::Integrations::Decorator < ::SimpleDelegator
  # @return [Decorator] a new instance of Decorator
  #
  # source://rr//lib/rr/integrations/decorator.rb#6
  def initialize(adapter); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/integrations/decorator.rb#15
  def applies?; end

  # source://rr//lib/rr/integrations/decorator.rb#24
  def load; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/integrations/decorator.rb#38
  def loaded?; end

  # source://rr//lib/rr/integrations/decorator.rb#11
  def name; end
end

# source://rr//lib/rr/integrations/minitest_4.rb#3
class RR::Integrations::MiniTest4
  # @return [Boolean]
  #
  # source://rr//lib/rr/integrations/minitest_4.rb#14
  def applies?; end

  # source://rr//lib/rr/integrations/minitest_4.rb#24
  def assertion_error_class; end

  # source://rr//lib/rr/integrations/minitest_4.rb#36
  def hook; end

  # source://rr//lib/rr/integrations/minitest_4.rb#32
  def mt_version; end

  # source://rr//lib/rr/integrations/minitest_4.rb#10
  def name; end

  # source://rr//lib/rr/integrations/minitest_4.rb#20
  def test_case_class; end

  # source://rr//lib/rr/integrations/minitest_4.rb#28
  def version_constant; end
end

# source://rr//lib/rr/integrations/minitest_4.rb#4
module RR::Integrations::MiniTest4::Mixin
  # source://rr//lib/rr/integrations/minitest_4.rb#5
  def assert_received(subject, &block); end
end

# source://rr//lib/rr/integrations/minitest_4_active_support.rb#3
class RR::Integrations::MiniTest4ActiveSupport
  # @return [MiniTest4ActiveSupport] a new instance of MiniTest4ActiveSupport
  #
  # source://rr//lib/rr/integrations/minitest_4_active_support.rb#4
  def initialize; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/integrations/minitest_4_active_support.rb#16
  def applies?; end

  # source://rr//lib/rr/integrations/minitest_4_active_support.rb#20
  def hook; end

  # source://rr//lib/rr/integrations/minitest_4_active_support.rb#12
  def name; end

  # source://rr//lib/rr/integrations/minitest_4_active_support.rb#8
  def parent_adapter_class; end
end

# source://rr//lib/rr/integrations/minitest.rb#3
class RR::Integrations::Minitest < ::RR::Integrations::MiniTest4
  # @return [Boolean]
  #
  # source://rr//lib/rr/integrations/minitest.rb#8
  def applies?; end

  # source://rr//lib/rr/integrations/minitest.rb#18
  def assertion_error_class; end

  # source://rr//lib/rr/integrations/minitest.rb#4
  def name; end

  # source://rr//lib/rr/integrations/minitest.rb#14
  def test_case_class; end

  # source://rr//lib/rr/integrations/minitest.rb#22
  def version_constant; end
end

# source://rr//lib/rr/integrations/minitest_active_support.rb#3
class RR::Integrations::MinitestActiveSupport < ::RR::Integrations::MiniTest4ActiveSupport
  # source://rr//lib/rr/integrations/minitest_active_support.rb#8
  def name; end

  # source://rr//lib/rr/integrations/minitest_active_support.rb#4
  def parent_adapter_class; end
end

# source://rr//lib/rr/integrations/rspec/invocation_matcher.rb#3
module RR::Integrations::RSpec; end

# source://rr//lib/rr/integrations/rspec_2.rb#3
class RR::Integrations::RSpec2
  # @return [Boolean]
  #
  # source://rr//lib/rr/integrations/rspec_2.rb#26
  def applies?; end

  # source://rr//lib/rr/integrations/rspec_2.rb#32
  def hook; end

  # source://rr//lib/rr/integrations/rspec_2.rb#22
  def name; end
end

# source://rr//lib/rr/integrations/rspec_2.rb#4
module RR::Integrations::RSpec2::Mixin
  # source://rr//lib/rr/integrations/rspec_2.rb#17
  def have_received(method = T.unsafe(nil)); end

  # source://rr//lib/rr/integrations/rspec_2.rb#5
  def setup_mocks_for_rspec; end

  # source://rr//lib/rr/integrations/rspec_2.rb#13
  def teardown_mocks_for_rspec; end

  # source://rr//lib/rr/integrations/rspec_2.rb#9
  def verify_mocks_for_rspec; end
end

# source://rr//lib/rr/integrations/rspec/invocation_matcher.rb#4
class RR::Integrations::RSpec::InvocationMatcher < ::RR::SpyVerificationProxy
  # @return [InvocationMatcher] a new instance of InvocationMatcher
  #
  # source://rr//lib/rr/integrations/rspec/invocation_matcher.rb#7
  def initialize(method = T.unsafe(nil)); end

  # Returns the value of attribute failure_message.
  #
  # source://rr//lib/rr/integrations/rspec/invocation_matcher.rb#5
  def failure_message; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/integrations/rspec/invocation_matcher.rb#13
  def matches?(subject); end

  # source://rr//lib/rr/integrations/rspec/invocation_matcher.rb#28
  def method_missing(method_name, *args, &block); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/integrations/rspec/invocation_matcher.rb#24
  def nil?; end

  # Returns the value of attribute spy_verification_proxy.
  #
  # source://rr//lib/rr/integrations/rspec/invocation_matcher.rb#5
  def spy_verification_proxy; end
end

# source://rr//lib/rr/keyword_arguments.rb#2
module RR::KeywordArguments
  class << self
    # source://rr//lib/rr/keyword_arguments.rb#5
    def fully_supported?; end
  end
end

# source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#2
module RR::MethodDispatches; end

# source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#3
class RR::MethodDispatches::BaseMethodDispatch
  include ::RR::Space::Reader
  extend ::Forwardable

  # source://forwardable/1.3.2/forwardable.rb#229
  def after_call_proc(*args, **_arg1, &block); end

  # Returns the value of attribute args.
  #
  # source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#7
  def args; end

  # Returns the value of attribute block.
  #
  # source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#7
  def block; end

  # @raise [NotImplementedError]
  #
  # source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#9
  def call; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def definition(*args, **_arg1, &block); end

  # Returns the value of attribute double.
  #
  # source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#7
  def double; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def doubles(*args, **_arg1, &block); end

  # Returns the value of attribute kwargs.
  #
  # source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#7
  def kwargs; end

  protected

  # source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#51
  def call_original_method_missing; end

  # source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#40
  def call_yields; end

  # source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#86
  def double_not_found_error; end

  # source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#75
  def extract_subject_from_return_value(return_value); end

  # source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#14
  def find_double_to_attempt; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/method_dispatches/base_method_dispatch.rb#71
  def implementation_is_original_method?; end
end

# source://rr//lib/rr/method_dispatches/method_dispatch.rb#3
class RR::MethodDispatches::MethodDispatch < ::RR::MethodDispatches::BaseMethodDispatch
  # @return [MethodDispatch] a new instance of MethodDispatch
  #
  # source://rr//lib/rr/method_dispatches/method_dispatch.rb#6
  def initialize(double_injection, subject, args, kwargs, block); end

  # source://rr//lib/rr/method_dispatches/method_dispatch.rb#15
  def call; end

  # source://rr//lib/rr/method_dispatches/method_dispatch.rb#32
  def call_original_method; end

  # Returns the value of attribute double_injection.
  #
  # source://rr//lib/rr/method_dispatches/method_dispatch.rb#4
  def double_injection; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def implementation(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def method_name(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def original_method_alias_name(*args, **_arg1, &block); end

  # Returns the value of attribute subject.
  #
  # source://rr//lib/rr/method_dispatches/method_dispatch.rb#4
  def subject; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def subject_has_original_method?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def subject_has_original_method_missing?(*args, **_arg1, &block); end

  protected

  # source://rr//lib/rr/method_dispatches/method_dispatch.rb#51
  def call_implementation; end
end

# source://rr//lib/rr/method_dispatches/method_missing_dispatch.rb#3
class RR::MethodDispatches::MethodMissingDispatch < ::RR::MethodDispatches::BaseMethodDispatch
  # @return [MethodMissingDispatch] a new instance of MethodMissingDispatch
  #
  # source://rr//lib/rr/method_dispatches/method_missing_dispatch.rb#12
  def initialize(subject, subject_class, method_name, args, kwargs, block); end

  # source://rr//lib/rr/method_dispatches/method_missing_dispatch.rb#21
  def call; end

  # source://rr//lib/rr/method_dispatches/method_missing_dispatch.rb#39
  def call_original_method; end

  # Returns the value of attribute method_name.
  #
  # source://rr//lib/rr/method_dispatches/method_missing_dispatch.rb#10
  def method_name; end

  # Returns the value of attribute subject.
  #
  # source://rr//lib/rr/method_dispatches/method_missing_dispatch.rb#10
  def subject; end

  # Returns the value of attribute subject_class.
  #
  # source://rr//lib/rr/method_dispatches/method_missing_dispatch.rb#10
  def subject_class; end

  protected

  # source://rr//lib/rr/method_dispatches/method_missing_dispatch.rb#46
  def call_implementation; end

  # source://rr//lib/rr/method_dispatches/method_missing_dispatch.rb#66
  def double_injection; end
end

# source://rr//lib/rr/recorded_call.rb#6
class RR::RecordedCall < ::Struct
  # source://rr//lib/rr/recorded_call.rb#17
  def ==(other); end

  # source://rr//lib/rr/recorded_call.rb#7
  def inspect; end

  private

  # source://rr//lib/rr/recorded_call.rb#27
  def subject_to_s; end
end

# source://rr//lib/rr/recorded_calls.rb#2
class RR::RecordedCalls
  include ::RR::Space::Reader

  # @return [RecordedCalls] a new instance of RecordedCalls
  #
  # source://rr//lib/rr/recorded_calls.rb#5
  def initialize(recorded_calls = T.unsafe(nil)); end

  # source://rr//lib/rr/recorded_calls.rb#33
  def ==(other); end

  # source://rr//lib/rr/recorded_calls.rb#12
  def [](index); end

  # source://rr//lib/rr/recorded_calls.rb#21
  def add(subject, method_name, arguments, keyword_arguments, block); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/recorded_calls.rb#29
  def any?(&block); end

  # source://rr//lib/rr/recorded_calls.rb#16
  def clear; end

  # source://rr//lib/rr/recorded_calls.rb#37
  def match_error(spy_verification); end

  # Returns the value of attribute recorded_calls.
  #
  # source://rr//lib/rr/recorded_calls.rb#10
  def recorded_calls; end

  protected

  # source://rr//lib/rr/recorded_calls.rb#50
  def double_injection_exists_error(spy_verification); end

  # source://rr//lib/rr/recorded_calls.rb#103
  def invocation_count_error(spy_verification, matching_recorded_calls); end

  # source://rr//lib/rr/recorded_calls.rb#93
  def match_argument_expectation(spy_verification); end

  # source://rr//lib/rr/recorded_calls.rb#86
  def match_double_injection(spy_verification); end

  # source://rr//lib/rr/recorded_calls.rb#80
  def matching_recorded_calls(spy_verification); end

  # Returns the value of attribute ordered_index.
  #
  # source://rr//lib/rr/recorded_calls.rb#48
  def ordered_index; end

  # Sets the attribute ordered_index
  #
  # @param value the value to set the attribute ordered_index to.
  #
  # source://rr//lib/rr/recorded_calls.rb#48
  def ordered_index=(_arg0); end

  # source://rr//lib/rr/recorded_calls.rb#61
  def ordered_match_error(spy_verification); end

  # source://rr//lib/rr/recorded_calls.rb#72
  def unordered_match_error(spy_verification); end
end

# RR::Space.instance is the global state subject for the RR framework.
#
# source://rr//lib/rr/space.rb#3
class RR::Space
  # @return [Space] a new instance of Space
  #
  # source://rr//lib/rr/space.rb#32
  def initialize; end

  # source://rr//lib/rr/space.rb#97
  def blank_slate_whitelist; end

  # Returns the value of attribute ordered_doubles.
  #
  # source://rr//lib/rr/space.rb#29
  def ordered_doubles; end

  # source://rr//lib/rr/space.rb#89
  def record_call(subject, method_name, arguments, keyword_arguments, block); end

  # Returns the value of attribute recorded_calls.
  #
  # source://rr//lib/rr/space.rb#29
  def recorded_calls; end

  # Registers the ordered Double to be verified.
  #
  # source://rr//lib/rr/space.rb#39
  def register_ordered_double(double); end

  # Resets the registered Doubles and ordered Doubles
  #
  # source://rr//lib/rr/space.rb#68
  def reset; end

  # Resets the DoubleInjection for the passed in subject and method_name.
  #
  # source://rr//lib/rr/space.rb#85
  def reset_double(subject, method_name); end

  # Returns the value of attribute trim_backtrace.
  #
  # source://rr//lib/rr/space.rb#30
  def trim_backtrace; end

  # Sets the attribute trim_backtrace
  #
  # @param value the value to set the attribute trim_backtrace to.
  #
  # source://rr//lib/rr/space.rb#30
  def trim_backtrace=(_arg0); end

  # Verifies all the DoubleInjection objects have met their
  # TimesCalledExpectations.
  #
  # source://rr//lib/rr/space.rb#62
  def verify(*subjects); end

  # Verifies the DoubleInjection for the passed in subject and method_name.
  #
  # source://rr//lib/rr/space.rb#80
  def verify_double(subject, method_name); end

  # Verifies all the DoubleInjection objects have met their
  # TimesCalledExpectations.
  #
  # source://rr//lib/rr/space.rb#62
  def verify_doubles(*subjects); end

  # Verifies that the passed in ordered Double is being called
  # in the correct position.
  #
  # source://rr//lib/rr/space.rb#45
  def verify_ordered_double(double); end

  protected

  # source://rr//lib/rr/space.rb#127
  def reset_bound_objects; end

  # source://rr//lib/rr/space.rb#109
  def reset_method_missing_injections; end

  # Removes the ordered Doubles from the list
  #
  # source://rr//lib/rr/space.rb#105
  def reset_ordered_doubles; end

  # source://rr//lib/rr/space.rb#123
  def reset_recorded_calls; end

  # source://rr//lib/rr/space.rb#116
  def reset_singleton_method_added_injections; end

  class << self
    # source://rr//lib/rr/space.rb#11
    def instance; end

    # Sets the attribute instance
    #
    # @param value the value to set the attribute instance to.
    #
    # source://rr//lib/rr/space.rb#14
    def instance=(_arg0); end

    protected

    # source://rr//lib/rr/space.rb#18
    def method_missing(method_name, *args, **kwargs, &block); end
  end
end

# source://rr//lib/rr/space.rb#4
module RR::Space::Reader
  # source://rr//lib/rr/space.rb#5
  def space; end
end

# source://rr//lib/rr/spy_verification.rb#2
class RR::SpyVerification
  include ::RR::DoubleDefinitions::DoubleDefinition::TimesDefinitionConstructionMethods
  include ::RR::DoubleDefinitions::DoubleDefinition::ArgumentDefinitionConstructionMethods

  # @return [SpyVerification] a new instance of SpyVerification
  #
  # source://rr//lib/rr/spy_verification.rb#3
  def initialize(subject, method_name, args, kwargs); end

  # Returns the value of attribute argument_expectation.
  #
  # source://rr//lib/rr/spy_verification.rb#11
  def argument_expectation; end

  # source://rr//lib/rr/spy_verification.rb#26
  def call; end

  # Returns the value of attribute method_name.
  #
  # source://rr//lib/rr/spy_verification.rb#11
  def method_name; end

  # source://rr//lib/rr/spy_verification.rb#17
  def ordered; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/spy_verification.rb#22
  def ordered?; end

  # Returns the value of attribute subject.
  #
  # source://rr//lib/rr/spy_verification.rb#12
  def subject; end

  # Sets the attribute subject
  #
  # @param value the value to set the attribute subject to.
  #
  # source://rr//lib/rr/spy_verification.rb#12
  def subject=(_arg0); end

  # source://rr//lib/rr/spy_verification.rb#36
  def subject_inspect; end

  # Returns the value of attribute times_matcher.
  #
  # source://rr//lib/rr/spy_verification.rb#11
  def times_matcher; end

  # source://rr//lib/rr/spy_verification.rb#30
  def to_proc; end

  protected

  # source://rr//lib/rr/spy_verification.rb#60
  def install_method_callback(return_value_block); end

  # source://rr//lib/rr/spy_verification.rb#47
  def set_argument_expectation_for_args(args, kwargs); end

  # Sets the attribute times_matcher
  #
  # @param value the value to set the attribute times_matcher to.
  #
  # source://rr//lib/rr/spy_verification.rb#45
  def times_matcher=(_arg0); end
end

# source://rr//lib/rr/spy_verification_proxy.rb#2
class RR::SpyVerificationProxy
  # @return [SpyVerificationProxy] a new instance of SpyVerificationProxy
  #
  # source://rr//lib/rr/spy_verification_proxy.rb#5
  def initialize(subject); end

  def __blank_slated_!; end

  # source://bson/4.15.0/lib/bson/object.rb#86
  def __blank_slated_as_extended_json(**options); end

  def __blank_slated_class; end
  def __blank_slated_clone(freeze: T.unsafe(nil)); end
  def __blank_slated_define_singleton_method(*_arg0); end
  def __blank_slated_display(*_arg0); end
  def __blank_slated_dup; end
  def __blank_slated_enum_for(*_arg0); end
  def __blank_slated_eql?(_arg0); end
  def __blank_slated_equal?(_arg0); end
  def __blank_slated_extend(*_arg0); end
  def __blank_slated_freeze; end
  def __blank_slated_frozen?; end

  # source://bundler/2.3.7/bundler/rubygems_integration.rb#256
  def __blank_slated_gem(dep, *reqs); end

  def __blank_slated_hash; end
  def __blank_slated_inspect; end
  def __blank_slated_instance_of?(_arg0); end
  def __blank_slated_instance_variable_defined?(_arg0); end
  def __blank_slated_instance_variable_get(_arg0); end
  def __blank_slated_instance_variable_set(_arg0, _arg1); end
  def __blank_slated_instance_variables; end
  def __blank_slated_is_a?(_arg0); end
  def __blank_slated_itself; end
  def __blank_slated_kind_of?(_arg0); end
  def __blank_slated_method(_arg0); end
  def __blank_slated_methods(*_arg0); end
  def __blank_slated_nil?; end

  # source://pp/0.3.0/pp.rb#617
  def __blank_slated_pretty_inspect; end

  # source://pp/0.3.0/pp.rb#317
  def __blank_slated_pretty_print(q); end

  # source://pp/0.3.0/pp.rb#334
  def __blank_slated_pretty_print_cycle(q); end

  # source://pp/0.3.0/pp.rb#356
  def __blank_slated_pretty_print_inspect; end

  # source://pp/0.3.0/pp.rb#345
  def __blank_slated_pretty_print_instance_variables; end

  def __blank_slated_private_methods(*_arg0); end
  def __blank_slated_protected_methods(*_arg0); end
  def __blank_slated_public_method(_arg0); end
  def __blank_slated_public_methods(*_arg0); end
  def __blank_slated_public_send(*_arg0); end
  def __blank_slated_remove_instance_variable(_arg0); end
  def __blank_slated_send(*_arg0); end
  def __blank_slated_singleton_class; end
  def __blank_slated_singleton_method(_arg0); end
  def __blank_slated_singleton_methods(*_arg0); end
  def __blank_slated_taint; end
  def __blank_slated_tainted?; end
  def __blank_slated_tap; end
  def __blank_slated_then; end

  # source://bson/4.15.0/lib/bson/object.rb#35
  def __blank_slated_to_bson_key(validating_keys = T.unsafe(nil)); end

  # source://bson/4.15.0/lib/bson/object.rb#47
  def __blank_slated_to_bson_normalized_key; end

  # source://bson/4.15.0/lib/bson/object.rb#59
  def __blank_slated_to_bson_normalized_value; end

  def __blank_slated_to_enum(*_arg0); end

  # source://bson/4.15.0/lib/bson/object.rb#72
  def __blank_slated_to_extended_json(**options); end

  def __blank_slated_to_json(*_arg0); end
  def __blank_slated_to_s; end

  # source://psych/4.0.3/psych/core_ext.rb#12
  def __blank_slated_to_yaml(options = T.unsafe(nil)); end

  def __blank_slated_trust; end
  def __blank_slated_untaint; end
  def __blank_slated_untrust; end
  def __blank_slated_untrusted?; end
  def __blank_slated_yield_self; end

  # source://rr//lib/rr/spy_verification_proxy.rb#10
  def method_missing(method_name, *args, **kwargs, &block); end
end

# source://rr//lib/rr/times_called_matchers/terminal.rb#2
module RR::TimesCalledMatchers; end

# source://rr//lib/rr/times_called_matchers/any_times_matcher.rb#3
class RR::TimesCalledMatchers::AnyTimesMatcher < ::RR::TimesCalledMatchers::TimesCalledMatcher
  include ::RR::TimesCalledMatchers::NonTerminal

  # @return [AnyTimesMatcher] a new instance of AnyTimesMatcher
  #
  # source://rr//lib/rr/times_called_matchers/any_times_matcher.rb#6
  def initialize; end

  # source://rr//lib/rr/times_called_matchers/any_times_matcher.rb#13
  def expected_times_message; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/any_times_matcher.rb#9
  def matches?(times_called); end
end

# source://rr//lib/rr/times_called_matchers/at_least_matcher.rb#3
class RR::TimesCalledMatchers::AtLeastMatcher < ::RR::TimesCalledMatchers::TimesCalledMatcher
  include ::RR::TimesCalledMatchers::NonTerminal

  # source://rr//lib/rr/times_called_matchers/at_least_matcher.rb#10
  def expected_times_message; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/at_least_matcher.rb#6
  def matches?(times_called); end
end

# source://rr//lib/rr/times_called_matchers/at_most_matcher.rb#3
class RR::TimesCalledMatchers::AtMostMatcher < ::RR::TimesCalledMatchers::TimesCalledMatcher
  include ::RR::TimesCalledMatchers::Terminal

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/at_most_matcher.rb#14
  def attempt?(times_called); end

  # source://rr//lib/rr/times_called_matchers/at_most_matcher.rb#18
  def expected_times_message; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/at_most_matcher.rb#10
  def matches?(times_called); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/at_most_matcher.rb#6
  def possible_match?(times_called); end
end

# source://rr//lib/rr/times_called_matchers/integer_matcher.rb#3
class RR::TimesCalledMatchers::IntegerMatcher < ::RR::TimesCalledMatchers::TimesCalledMatcher
  include ::RR::TimesCalledMatchers::Terminal

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/integer_matcher.rb#14
  def attempt?(times_called); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/integer_matcher.rb#10
  def matches?(times_called); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/integer_matcher.rb#6
  def possible_match?(times_called); end
end

# source://rr//lib/rr/times_called_matchers/never_matcher.rb#3
class RR::TimesCalledMatchers::NeverMatcher < ::RR::TimesCalledMatchers::TimesCalledMatcher
  include ::RR::TimesCalledMatchers::Terminal

  # @return [NeverMatcher] a new instance of NeverMatcher
  #
  # source://rr//lib/rr/times_called_matchers/never_matcher.rb#6
  def initialize; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/never_matcher.rb#18
  def attempt?(times_called); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/never_matcher.rb#14
  def matches?(times_called); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/never_matcher.rb#10
  def possible_match?(times_called); end
end

# Including this module marks the TimesCalledMatcher as NonTerminal.
# Being NonTerminal means the Double will not "terminate" even when
# called infinite times.
#
# The Double that uses a NonTerminal TimesCalledMatcher will
# continue using the Double when passed the matching arguments.
# This is done by the attempt? always returning true.
#
# This is in opposition to Terminal TimesCalledMatchers, where
# attempt? will eventually return false.
#
# source://rr//lib/rr/times_called_matchers/non_terminal.rb#13
module RR::TimesCalledMatchers::NonTerminal
  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/non_terminal.rb#22
  def attempt?(times_called); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/non_terminal.rb#18
  def possible_match?(times_called); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/non_terminal.rb#14
  def terminal?; end
end

# source://rr//lib/rr/times_called_matchers/proc_matcher.rb#3
class RR::TimesCalledMatchers::ProcMatcher < ::RR::TimesCalledMatchers::TimesCalledMatcher
  include ::RR::TimesCalledMatchers::NonTerminal

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/proc_matcher.rb#6
  def matches?(times_called); end
end

# source://rr//lib/rr/times_called_matchers/range_matcher.rb#3
class RR::TimesCalledMatchers::RangeMatcher < ::RR::TimesCalledMatchers::TimesCalledMatcher
  include ::RR::TimesCalledMatchers::Terminal

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/range_matcher.rb#16
  def attempt?(times_called); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/range_matcher.rb#12
  def matches?(times_called); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/range_matcher.rb#6
  def possible_match?(times_called); end
end

# Including this module marks the TimesCalledMatcher as Terminal.
# Being Terminal the Double will "terminate" when times called is
# finite.
#
# The Double that uses a Terminal TimesCalledMatcher will
# eventually be passed over to the next Double when passed
# the matching arguments enough times. This is done by the attempt?
# method returning false when executed a finite number of times.
#
# This is in opposition to NonTerminal TimesCalledMatchers, where
# attempt? will always return true.
#
# source://rr//lib/rr/times_called_matchers/terminal.rb#14
module RR::TimesCalledMatchers::Terminal
  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/terminal.rb#15
  def terminal?; end
end

# source://rr//lib/rr/times_called_matchers/times_called_matcher.rb#3
class RR::TimesCalledMatchers::TimesCalledMatcher
  # @return [TimesCalledMatcher] a new instance of TimesCalledMatcher
  #
  # source://rr//lib/rr/times_called_matchers/times_called_matcher.rb#16
  def initialize(times); end

  # source://rr//lib/rr/times_called_matchers/times_called_matcher.rb#30
  def ==(other); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/times_called_matcher.rb#23
  def attempt?(times_called); end

  # source://rr//lib/rr/times_called_matchers/times_called_matcher.rb#26
  def error_message(times_called); end

  # source://rr//lib/rr/times_called_matchers/times_called_matcher.rb#34
  def expected_times_message; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/times_called_matchers/times_called_matcher.rb#20
  def matches?(times_called); end

  # Returns the value of attribute times.
  #
  # source://rr//lib/rr/times_called_matchers/times_called_matcher.rb#14
  def times; end

  protected

  # source://rr//lib/rr/times_called_matchers/times_called_matcher.rb#39
  def pluralized_time(times_called); end
end

# source://rr//lib/rr/version.rb#2
RR::VERSION = T.let(T.unsafe(nil), String)

# = Writing your own custom wildcard matchers.
# Writing new wildcard matchers is not too difficult.  If you've ever written
# a custom expectation in RSpec, the implementation is very similar.
#
# As an example, let's say that you want a matcher that will match any number
# divisible by a certain integer.  In use, it might look like this:
#
#   # Will pass if BananaGrabber#bunch_bananas is called with an integer
#   # divisible by 5.
#
#   mock(BananaGrabber).bunch_bananas(divisible_by(5))
#
# To implement this, we need a class RR::WildcardMatchers::DivisibleBy with
# these instance methods:
#
# * ==(other)
# * eql?(other) (usually aliased to #==)
# * inspect
# * wildcard_match?(other)
#
# and optionally, a sensible initialize method.  Let's look at each of these.
#
# === .initialize
#
# Most custom wildcard matchers will want to define initialize to store
# some information about just what should be matched.  DivisibleBy#initialize
# might look like this:
#
#   class RR::WildcardMatchers::DivisibleBy
#     def initialize(divisor)
#       @expected_divisor = divisor
#     end
#   end
#
# === #==(other)
# DivisibleBy#==(other) should return true if other is a wildcard matcher that
# matches the same things as self, so a natural way to write DivisibleBy#== is:
#
#
#   class RR::WildcardMatchers::DivisibleBy
#     def ==(other)
#       # Ensure that other is actually a DivisibleBy
#       return false unless other.is_a?(self.class)
#
#       # Does other expect to match the same divisor we do?
#       self.expected_divisor = other.expected_divisor
#     end
#   end
#
# Note that this implementation of #== assumes that we've also declared
#   attr_reader :expected_divisor
#
# === #inspect
#
# Technically we don't have to declare DivisibleBy#inspect, since inspect is
# defined for every object already.  But putting a helpful message in inspect
# will make test failures much clearer, and it only takes about two seconds to
# write it, so let's be nice and do so:
#
#   class RR::WildcardMatchers::DivisibleBy
#     def inspect
#       "integer divisible by #{expected.divisor}"
#     end
#   end
#
# Now if we run the example from above:
#
#   mock(BananaGrabber).bunch_bananas(divisible_by(5))
#
# and it fails, we get a helpful message saying
#
#   bunch_bananas(integer divisible by 5)
#   Called 0 times.
#   Expected 1 times.
#
# === #wildcard_matches?(other)
#
# wildcard_matches? is the method that actually checks the argument against the
# expectation.  It should return true if other is considered to match,
# false otherwise.  In the case of DivisibleBy, wildcard_matches? reads:
#
#   class RR::WildcardMatchers::DivisibleBy
#     def wildcard_matches?(other)
#       # If other isn't a number, how can it be divisible by anything?
#       return false unless other.is_a?(Numeric)
#
#       # If other is in fact divisible by expected_divisor, then
#       # other modulo expected_divisor should be 0.
#
#       other % expected_divisor == 0
#     end
#   end
#
# === A finishing touch: wrapping it neatly
#
# We could stop here if we were willing to resign ourselves to using
# DivisibleBy this way:
#
#   mock(BananaGrabber).bunch_bananas(DivisibleBy.new(5))
#
# But that's less expressive than the original:
#
#   mock(BananaGrabber).bunch_bananas(divisible_by(5))
#
# To be able to use the convenient divisible_by matcher rather than the uglier
# DivisibleBy.new version, re-open the module RR::DSL and define divisible_by
# there as a simple wrapper around DivisibleBy.new:
#
#   module RR::DSL
#     def divisible_by(expected_divisor)
#       RR::WildcardMatchers::DivisibleBy.new(expected_divisor)
#     end
#   end
#
# == Recap
#
# Here's all the code for DivisibleBy in one place for easy reference:
#
#   class RR::WildcardMatchers::DivisibleBy
#     def initialize(divisor)
#       @expected_divisor = divisor
#     end
#
#     def ==(other)
#       # Ensure that other is actually a DivisibleBy
#       return false unless other.is_a?(self.class)
#
#       # Does other expect to match the same divisor we do?
#       self.expected_divisor = other.expected_divisor
#     end
#
#     def inspect
#       "integer divisible by #{expected.divisor}"
#     end
#
#     def wildcard_matches?(other)
#       # If other isn't a number, how can it be divisible by anything?
#       return false unless other.is_a?(Numeric)
#
#       # If other is in fact divisible by expected_divisor, then
#       # other modulo expected_divisor should be 0.
#
#       other % expected_divisor == 0
#     end
#   end
#
#   module RR::DSL
#     def divisible_by(expected_divisor)
#       RR::WildcardMatchers::DivisibleBy.new(expected_divisor)
#     end
#   end
#
# source://rr//lib/rr/wildcard_matchers/anything.rb#2
module RR::WildcardMatchers; end

# source://rr//lib/rr/wildcard_matchers/anything.rb#3
class RR::WildcardMatchers::Anything
  # source://rr//lib/rr/wildcard_matchers/anything.rb#8
  def ==(other); end

  # source://rr//lib/rr/wildcard_matchers/anything.rb#8
  def eql?(other); end

  # source://rr//lib/rr/wildcard_matchers/anything.rb#13
  def inspect; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/wildcard_matchers/anything.rb#4
  def wildcard_match?(other); end
end

# source://rr//lib/rr/wildcard_matchers/boolean.rb#3
class RR::WildcardMatchers::Boolean
  # source://rr//lib/rr/wildcard_matchers/boolean.rb#9
  def ==(other); end

  # source://rr//lib/rr/wildcard_matchers/boolean.rb#9
  def eql?(other); end

  # source://rr//lib/rr/wildcard_matchers/boolean.rb#14
  def inspect; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/wildcard_matchers/boolean.rb#4
  def wildcard_match?(other); end
end

# source://rr//lib/rr/wildcard_matchers/duck_type.rb#3
class RR::WildcardMatchers::DuckType
  # @return [DuckType] a new instance of DuckType
  #
  # source://rr//lib/rr/wildcard_matchers/duck_type.rb#6
  def initialize(*required_methods); end

  # source://rr//lib/rr/wildcard_matchers/duck_type.rb#15
  def ==(other); end

  # source://rr//lib/rr/wildcard_matchers/duck_type.rb#15
  def eql?(other); end

  # source://rr//lib/rr/wildcard_matchers/duck_type.rb#21
  def inspect; end

  # Returns the value of attribute required_methods.
  #
  # source://rr//lib/rr/wildcard_matchers/duck_type.rb#4
  def required_methods; end

  # Sets the attribute required_methods
  #
  # @param value the value to set the attribute required_methods to.
  #
  # source://rr//lib/rr/wildcard_matchers/duck_type.rb#4
  def required_methods=(_arg0); end

  # @return [Boolean]
  #
  # source://rr//lib/rr/wildcard_matchers/duck_type.rb#10
  def wildcard_match?(other); end
end

# source://rr//lib/rr/wildcard_matchers/hash_including.rb#3
class RR::WildcardMatchers::HashIncluding
  # @return [HashIncluding] a new instance of HashIncluding
  #
  # source://rr//lib/rr/wildcard_matchers/hash_including.rb#6
  def initialize(expected_hash); end

  # source://rr//lib/rr/wildcard_matchers/hash_including.rb#19
  def ==(other); end

  # source://rr//lib/rr/wildcard_matchers/hash_including.rb#19
  def eql?(other); end

  # Returns the value of attribute expected_hash.
  #
  # source://rr//lib/rr/wildcard_matchers/hash_including.rb#4
  def expected_hash; end

  # source://rr//lib/rr/wildcard_matchers/hash_including.rb#25
  def inspect; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/wildcard_matchers/hash_including.rb#10
  def wildcard_match?(other); end
end

# source://rr//lib/rr/wildcard_matchers/is_a.rb#3
class RR::WildcardMatchers::IsA
  # @return [IsA] a new instance of IsA
  #
  # source://rr//lib/rr/wildcard_matchers/is_a.rb#6
  def initialize(klass); end

  # source://rr//lib/rr/wildcard_matchers/is_a.rb#14
  def ==(other); end

  # source://rr//lib/rr/wildcard_matchers/is_a.rb#14
  def eql?(other); end

  # source://rr//lib/rr/wildcard_matchers/is_a.rb#19
  def inspect; end

  # Returns the value of attribute klass.
  #
  # source://rr//lib/rr/wildcard_matchers/is_a.rb#4
  def klass; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/wildcard_matchers/is_a.rb#10
  def wildcard_match?(other); end
end

# source://rr//lib/rr/wildcard_matchers/numeric.rb#3
class RR::WildcardMatchers::Numeric < ::RR::WildcardMatchers::IsA
  # @return [Numeric] a new instance of Numeric
  #
  # source://rr//lib/rr/wildcard_matchers/numeric.rb#4
  def initialize; end

  # source://rr//lib/rr/wildcard_matchers/numeric.rb#8
  def inspect; end
end

# source://rr//lib/rr/wildcard_matchers/satisfy.rb#3
class RR::WildcardMatchers::Satisfy
  # @return [Satisfy] a new instance of Satisfy
  #
  # source://rr//lib/rr/wildcard_matchers/satisfy.rb#6
  def initialize(expectation_proc); end

  # source://rr//lib/rr/wildcard_matchers/satisfy.rb#15
  def ==(other); end

  # source://rr//lib/rr/wildcard_matchers/satisfy.rb#15
  def eql?(other); end

  # Returns the value of attribute expectation_proc.
  #
  # source://rr//lib/rr/wildcard_matchers/satisfy.rb#4
  def expectation_proc; end

  # source://rr//lib/rr/wildcard_matchers/satisfy.rb#21
  def inspect; end

  # @return [Boolean]
  #
  # source://rr//lib/rr/wildcard_matchers/satisfy.rb#10
  def wildcard_match?(other); end
end

# source://rr//lib/rr/core_ext/range.rb#1
class Range
  include ::Enumerable

  # @return [Boolean]
  #
  # source://rr//lib/rr/core_ext/range.rb#2
  def wildcard_match?(other); end
end

# source://rr//lib/rr/core_ext/regexp.rb#1
class Regexp
  include ::BSON::JSON

  # @return [Boolean]
  #
  # source://rr//lib/rr/core_ext/regexp.rb#2
  def wildcard_match?(other); end
end

# source://regexp_parser/2.5.0/lib/regexp_parser/token.rb#2
Regexp::TOKEN_KEYS = T.let(T.unsafe(nil), Array)
