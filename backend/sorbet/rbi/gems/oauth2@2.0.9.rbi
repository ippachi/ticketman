# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `oauth2` gem.
# Please instead update this file by running `bin/tapioca gem oauth2`.

module OAuth2
  private

  def configure; end

  class << self
    def config; end
    def config=(_arg0); end
    def configure; end
  end
end

class OAuth2::AccessToken
  def initialize(client, token, opts = T.unsafe(nil)); end

  def [](key); end
  def client; end
  def delete(path, opts = T.unsafe(nil), &block); end
  def expired?; end
  def expires?; end
  def expires_at; end
  def expires_in; end
  def expires_latency; end
  def get(path, opts = T.unsafe(nil), &block); end
  def headers; end
  def options; end
  def options=(_arg0); end
  def params; end
  def patch(path, opts = T.unsafe(nil), &block); end
  def post(path, opts = T.unsafe(nil), &block); end
  def put(path, opts = T.unsafe(nil), &block); end
  def refresh(params = T.unsafe(nil), access_token_opts = T.unsafe(nil)); end
  def refresh!(params = T.unsafe(nil), access_token_opts = T.unsafe(nil)); end
  def refresh_token; end
  def refresh_token=(_arg0); end
  def request(verb, path, opts = T.unsafe(nil), &block); end
  def response; end
  def response=(_arg0); end
  def to_hash; end
  def token; end

  private

  def configure_authentication!(opts); end
  def convert_expires_at(expires_at); end

  class << self
    def from_hash(client, hash); end
    def from_kvform(client, kvform); end

    private

    def extra_tokens_warning(supported_keys, key); end
  end
end

OAuth2::AccessToken::TOKEN_KEYS_STR = T.let(T.unsafe(nil), Array)
OAuth2::AccessToken::TOKEN_KEYS_SYM = T.let(T.unsafe(nil), Array)
OAuth2::AccessToken::TOKEN_KEY_LOOKUP = T.let(T.unsafe(nil), Array)

class OAuth2::Authenticator
  def initialize(id, secret, mode); end

  def apply(params); end
  def id; end
  def mode; end
  def secret; end

  private

  def apply_basic_auth(params); end
  def apply_client_id(params); end
  def apply_params_auth(params); end
  def basic_auth_header; end

  class << self
    def encode_basic_auth(user, password); end
  end
end

class OAuth2::Client
  def initialize(client_id, client_secret, options = T.unsafe(nil), &block); end

  def assertion; end
  def auth_code; end
  def authorize_url(params = T.unsafe(nil)); end
  def client_credentials; end
  def connection; end
  def connection=(_arg0); end
  def get_token(params, access_token_opts = T.unsafe(nil), extract_access_token = T.unsafe(nil), &block); end
  def http_method; end
  def id; end
  def implicit; end
  def options; end
  def options=(_arg0); end
  def password; end
  def redirection_params; end
  def request(verb, url, opts = T.unsafe(nil), &block); end
  def secret; end
  def site; end
  def site=(value); end
  def token_url(params = T.unsafe(nil)); end

  private

  def authenticator; end
  def build_access_token(response, access_token_opts, access_token_class); end
  def build_access_token_legacy(response, access_token_opts, extract_access_token); end
  def execute_request(verb, url, opts = T.unsafe(nil)); end
  def oauth_debug_logging(builder); end
  def parse_response(response, access_token_opts); end
  def parse_response_legacy(response, access_token_opts, extract_access_token); end
  def parse_snaky_params_headers(params); end
end

OAuth2::Client::RESERVED_PARAM_KEYS = T.let(T.unsafe(nil), Array)
class OAuth2::ConnectionError < ::Faraday::ConnectionFailed; end
OAuth2::DEFAULT_CONFIG = T.let(T.unsafe(nil), SnakyHash::SymbolKeyed)

class OAuth2::Error < ::StandardError
  def initialize(response); end

  def body; end
  def code; end
  def description; end
  def response; end

  private

  def error_message(response_body, opts = T.unsafe(nil)); end
  def parse_error_description(code, description); end
end

class OAuth2::Response
  def initialize(response, parse: T.unsafe(nil), snaky: T.unsafe(nil), **options); end

  def body; end
  def content_type; end
  def headers; end
  def options; end
  def options=(_arg0); end
  def parsed; end
  def parser; end
  def response; end
  def status; end

  class << self
    def register_parser(key, mime_types, &block); end
  end
end

OAuth2::Response::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)
module OAuth2::Strategy; end

class OAuth2::Strategy::Assertion < ::OAuth2::Strategy::Base
  def authorize_url; end
  def get_token(claims, encoding_opts, request_opts = T.unsafe(nil), response_opts = T.unsafe(nil)); end

  private

  def build_assertion(claims, encoding_opts); end
  def build_request(assertion, request_opts = T.unsafe(nil)); end
end

class OAuth2::Strategy::AuthCode < ::OAuth2::Strategy::Base
  def authorize_params(params = T.unsafe(nil)); end
  def authorize_url(params = T.unsafe(nil)); end
  def get_token(code, params = T.unsafe(nil), opts = T.unsafe(nil)); end

  private

  def assert_valid_params(params); end
end

class OAuth2::Strategy::Base
  def initialize(client); end
end

class OAuth2::Strategy::ClientCredentials < ::OAuth2::Strategy::Base
  def authorize_url; end
  def get_token(params = T.unsafe(nil), opts = T.unsafe(nil)); end
end

class OAuth2::Strategy::Implicit < ::OAuth2::Strategy::Base
  def authorize_params(params = T.unsafe(nil)); end
  def authorize_url(params = T.unsafe(nil)); end
  def get_token(*_arg0); end

  private

  def assert_valid_params(params); end
end

class OAuth2::Strategy::Password < ::OAuth2::Strategy::Base
  def authorize_url; end
  def get_token(username, password, params = T.unsafe(nil), opts = T.unsafe(nil)); end
end

class OAuth2::TimeoutError < ::Faraday::TimeoutError; end

module OAuth2::Version
  extend ::VersionGem::Basic
  extend ::VersionGem::Api
end

OAuth2::Version::VERSION = T.let(T.unsafe(nil), String)
